-- Отделы
INSERT INTO public.department
(id, department_name)
VALUES(10000001, 'Аналитический отдел');
INSERT INTO public.department
(id, department_name)
VALUES(10000002, 'Отдел разработки');
INSERT INTO public.department
(id, department_name)
VALUES(10000003, 'Отдел тестирования');
INSERT INTO public.department
(id, department_name)
VALUES(10000004, 'Тех. поддержка');

-- Сотрудники
INSERT INTO public.employee
(id, date_of_birth, email, login, "name", "password", "role", status, department_id)
VALUES(10000002, '1992-02-22 00:00:00.000', 'petrov92@mail.ru', 'petrov92', 'Петров Петр', '$2a$12$iNNjqLusskSk3GQBnu7/kOpuvR3t1QP0b1MKBHSB0zN3NzbxeE6Xu', 'USER', 'ACTIVE', 10000001);
INSERT INTO public.employee
(id, date_of_birth, email, login, "name", "password", "role", status, department_id)
VALUES(10000003, '1998-12-15 00:00:00.000', 'sidor98@mail.ru', 'sidor98', 'Сидоров Сергей', '$2a$12$QP5fXOfFUPOcYyw.uzf5Wezh6wElEu/NJiErnqUPdHGu6CM2Vu51W', 'USER', 'ACTIVE', 10000001);
INSERT INTO public.employee
(id, date_of_birth, email, login, "name", "password", "role", status, department_id)
VALUES(10000001, '2000-12-15 00:00:00.000', 'ivanov2000@mail.ru', 'ivanov2000', 'Иванов Иван', '$2a$12$LyqHOjVQnegxlTfhiofbEeurau43bt3YH7IxviM48Xxsh50kV8yBm', 'USER', 'ACTIVE', 10000002);
INSERT INTO public.employee
(id, date_of_birth, email, login, "name", "password", "role", status, department_id)
VALUES(10000005, '1978-09-30 00:00:00.000', 'eddianton@mail.ru', 'eddianton', 'Антон Эдуард', '$2a$12$uJjxaNgs3z2WIptUdhuX3OowMu1N6ehLOIWK.VnzdeSuLFcsr1RI6', 'ADMIN', 'ACTIVE', 0);
INSERT INTO public.employee
(id, date_of_birth, email, login, "name", "password", "role", status, department_id)
VALUES(10000006, '1980-05-10 00:00:00.000', 'alex80@mail.ru', 'alex80', 'Александров Александр', '$2a$12$t0yAE3AJDi91zonWMV3yO.6gmaepU7Nx5FO5MPx/upFXRrBBxzwqy', 'USER', 'ACTIVE', 10000003);
INSERT INTO public.employee
(id, date_of_birth, email, login, "name", "password", "role", status, department_id)
VALUES(10000007, '1982-11-22 00:00:00.000', 'musa82@mail.ru', 'musa82', 'Мусин Муса', '$2a$12$dWo6DJRYX1xxzyFSB7jyeeJ71mp1vxPi6br90bdlFZSNDAZsq6qdO', 'USER', 'ACTIVE', 10000004);
INSERT INTO public.employee
(id, date_of_birth, email, login, "name", "password", "role", status, department_id)
VALUES(10000008, '1997-06-05 00:00:00.000', 'kos1997@mail.ru', 'kos1997', 'Костин Константин', '$2a$12$111mLckHdafyWFIn7jr2sOgezBtJl6mtrdlAiSOKX3ljQRnGE4lNm', 'USER', 'ACTIVE', 10000004);
INSERT INTO public.employee
(id, date_of_birth, email, login, "name", "password", "role", status, department_id)
VALUES(10000009, '1980-04-17 00:00:00.000', 'alex1980@mail.ru', 'alex1980', 'Южаков Алексей', '$2a$12$3IJZEE9p1EeAl2Rni19aaeBAk4HPCjj.BYV9MPz8h4OVxaewYh3Gq', 'USER', 'BANNED', 10000002);
INSERT INTO public.employee
(id, date_of_birth, email, login, "name", "password", "role", status, department_id)
VALUES(100000010, '1989-08-07 00:00:00.000', 'toha89@mail.ru', 'toha89', 'Антонов Антон', '$2a$12$PL6ftr6256LdJLR7fJa4.eX6ClmFca0Sj3n/K.vGl7M/SEhL57r0q', 'USER', 'ACTIVE', 10000002);
INSERT INTO public.employee
(id, date_of_birth, email, login, "name", "password", "role", status, department_id)
VALUES(100000011, '1997-07-16 00:00:00.000', 'kotik97@mail.ru', 'kotik97', 'Котова Мария', '$2a$12$DBfcD225cEx8XYE2OdbdjOPkvodmXOP0NIUhHfsYL8eIIv7.KTOFC', 'USER', 'BANNED', 10000003);

-- Доклады
INSERT INTO public.report
(id, "content", date_created, title, author_id)
VALUES(10000001, 'На сегодняшний день, информационные технологии довольно сильно помогают людям в повседневной жизни и во многом являются основным источником для достижения цели. Если раньше использование компьютерных программ не выходило за рамки вычислений математически сложных задач, то сейчас практически невозможно представить без них нашу жизнь.
Неотъемлемой частью деятельности любой компании является необходимость проведения разного рода собраний сотрудников, для чего необходимо быстро составить список участников с указанием фамилии имени и отчества. Это могут быть собрания рабочих групп, отделов или собрания на высшем уровне, митапы и даже собрания жильцов ТСЖ. Очень часто мы не помним фамилий или подразделений в которых работают сотрудники. В таких случаях берется лист бумаги и производится запись. Однако это происходит долго , утомительно, с обращением к дополнительным бумажным либо электронным каталогам. В последствии эти записи нередко теряются, что не позволяет должным образом вести своего рода архив.
Исходя из вышесказанного, вырисовывается задача сделать приложение, которое сможет совместить в себе функции журнала и архива проведенных, а также запланированных собраний, с возможностью поиска по определенным фильтрам. Для большей конкретики — необходимо хранить тексты подготовленных и озвученных докладов. Для еще большего расширения функционала можно добавить сервис рассылки уведомлений сотрудникам, помеченным как участник собрания.
В связи с этим я выбрал темой своей выпускной работы – разработку приложения для ведения учета собраний на предприятии, так как считаю эту тему актуальной.
', '2022-12-04 03:17:49.068', 'Введение', 10000005);
INSERT INTO public.report
(id, "content", date_created, title, author_id)
VALUES(10000002, 'Пожалуй самым важным решением был выбор языка программирования для реализации проекта. Главными критериями были: популярность языка, наличие большого количества информации о нем, кроссплатформенность, широкий набор инструментов облегчающих процесс разработки, большое комьюнити программистов, а так же направления будущего развития с этим языком. В итоге я остановил свой выбор на Java.
Java – это многоплатформенный, объектно-ориентированный, быстрый, безопасный и надежный язык программирования для всего: от мобильных приложений и корпоративного ПО до приложений для работы с большими данными и серверных технологий. Он был изобретен Джеймсом Гослингом в 1995 году, когда он работал в Sun Microsystems.
Язык Java был разработан с использованием синтаксиса, аналогичного языку C++, поэтому он уже был знаком программистам, когда они начинали его использовать. С лозунгом «написать один раз, запускать где угодно» в своей основе программист мог написать код Java для одной платформы, а затем запускать на любой другой. где установлена среда исполнения JRE. Это происходит за счет компиляции написанного кода на Java в байт-код. Затем этот код исполняет JVM (виртуальная машина Java). Виртуальная машина не зависит от платформы. В Java нет необходимости освобождать память, этим занимается сборщик мусора (garbage collector) [3.].
Кей Хорстман в своей книге [3.] делает упор на том, что язык Java имеет следующие преимущества:
1) Java был создан для ООП. В результате чего можно создавать код, который может переиспользоваться многократно.
2) Java платформонезависимый язык. Основным преимуществом языка Java является возможность запуска программ в разных системах.
3) Многопоточный. Есть возможность писать программы, которые будут выполнять множество задач одновременно.
4) Надежность. Java является строго типизированным языком, что является важной особенностью для обеспечения безопасности.
6) Динамический. Программирование на Java является высоко динамичным, потому что он постоянно адаптируется к быстро меняющимся окружающим реалиям.
	Для меня есть четыре основные причины, по которым этот язык был выбран для разработки:
	1) Расширяемость
	Язык Java достаточно просто расширяем, для разработки веб-приложений, если будет потребность в масштабировании приложения. Это делает его действительно удобным для достижения долгосрочных целей.
	2) Фреймворки
	Существует множество фреймворков для разработки на Java, которые
делают этот процесс быстрее и проще. Более того, каждый популярный фреймворк имеет огромное количество всей необходимой документации и  поддержку сообщества.
	3) Независимая платформа
	Нет необходимости в конкретной платформе. Java — отличный пример
переносимости кода.
	4) Сборщик мусора
	Java легко справляется с очисткой мусора, при переполнении кучи мусор собирается и уничтожается. Что опять же делает этот язык подходящим, например, с точки зрения процесса масштабирования приложения.
', '2022-12-04 03:18:46.165', 'Язык Java', 10000006);
INSERT INTO public.report
(id, "content", date_created, title, author_id)
VALUES(10000003, 'До начала разработки необходимо определиться со средой программирования, хорошо подходящей для выбранного языка. Ниже представлены лучшие IDE для разработки на Java:
    • Eclipse
    • IntelliJ IDEA
    • NetBeans
    • Jdeveloper
    • BlueJ
	Я остановил свой выбор на Intellij IDEA и его стандартных встроенных возможностях, т.к. они могут полностью удовлетворить нужды приложения. 	IntelliJ IDEA Community Edition - это бесплатная среда разработки для программирования на Java. Некоторые из языков программирования, которые поддерживаются этой IDE, включают программирование на Java, Go, Scala, Kotlin, Groovy, Python и др. Так же данная среда содержит множество других функций, таких как выполнение тестов , отладка, автоматическое завершение, автоматическая проверка кода с выведением подсказок, рефакторинг кода, визуальный графический редактор и др. [6.].
	IntelliJ - это облегченная IDE. Это означает, что для ее использования не нужен высококлассный компьютер.
	В данной IDE, благодаря большому количеству плагинов, можно использовать контроль версий (Git), контейнеризацию (Docker) и многие другие полезные функции.
	', '2022-12-04 03:19:52.884', 'Intellij IDEA', 100000010);
INSERT INTO public.report
(id, "content", date_created, title, author_id)
VALUES(10000004, 'Thymeleaf - это современный механизм шаблонов Java на стороне сервера, способный обрабатывать HTML, XML, JavaScript, CSS и даже обычный текст. Он больше подходит для работы с XHTML/HTML5 на уровне представления веб-приложений соответствующих паттерну MVC , но может обрабатывать проивольные XML-файлы даже в автономных средах. Thymeleaf предлагает полную интеграцию с платформой Spring.
Основная цель Thymeleaf — создать элегантный и простой в использовании метод шаблонизации. Для этого Thymeleaf внедряет свою логику в файлы шаблонов так, чтобы она не влияла на отображение прототипа дизайна. Thymeleaf разрабатывался учитывая стандарты Web, и в особенности HTML5, поэтому можно создавать шаблоны, полностью соответствующие стандартам.
По умолчанию Thymeleaf поддерживает шесть, так называемых, форматов шаблона: XML, HTML, TEXT, JAVASCRIPT, CSS и RAW. Форматы шаблонов отличаются разным уровнем строгости синтаксического анализатора.
Несколько примеров форматов шаблона:
1) XML: высокий уровень проверки, синтаксический анализатор выдаст исключение при отсутствии закрывающих тегов, кавычек и т. д., проверка на соответствие DTD не выполняется.
2) HTML: формат HTML означает стандарты HTML, включая HTML5, HTML 4 и XHTML. Проверка не выполняется, и код/структура исходного шаблона максимально соблюдаются.
Рассматриваемый шаблонизатор работает как в веб-средах, так и не в Интернете (офлайн), на основе модульных наборов функций, называемых диалектами. Функции диалекта (например оценка, итерация и т. д.) применяются путем связывания их с тегами и/или атрибутами шаблона. По умолчанию доступны два диалекта: стандартный и SpringStandard (тот же синтаксис, что и у Standard для приложений Spring MVC). Разработчики могут расширять и создавать свои собственные диалекты.
Основные преимущества  Thymeleaf:
1) Автоматическое преобразование DOCTYPE из шаблона DTD в результат DTD для проверки как шаблона, так и кода результата .
2) Высокая масштабируемость. При желании можно использовать в  качестве конструкции механизма шаблонов.
3) Полная документация с большим количеством примеров использования в приложениях.
4) Для веб-приложений Thymeleaf стремится полностью заменить JavaServerPages (JSP), а также реализует концепцию, согласно которой файлы шаблонов можно открывать непосредственно в браузерах и они отображаются как веб-страницы.', '2022-12-04 03:20:49.026', 'Thymeleaf', 10000003);
INSERT INTO public.report
(id, "content", date_created, title, author_id)
VALUES(10000005, 'Следующим шагом был выбор базы данных для связи с приложением. База данных служит для хранения информации, которой будет управлять пользователь.
СУБД это комплекс инструментов, позволяющих создать базу данных и управлять данными (добавлять, обновлять, удалять и получать). Система обеспечивает целостность данных, их безопасное хранение, а также предоставляет средства для администрировdepartmentания [2.].
В настоящее время, наиболее популярными являются PostgreSQL, MySQL и MongoDB. Изучив информацию о них я посчитал разумным остановить свой выбор на PostgreSQL. Разрабатываемое мной приложение является небольшим и не требует той гибкости, которую предлагает MongoDB, в свою очередь MySQL не имеет достаточного развития, которого требуют постоянно меняющиеся реалии информационного сообщества.
PostgreSQL это одна из самых популярных свободно распространяемых объектно-реляционных систем управления базами данных. Она основана на языке SQL и имеет многочисленные возможности [1.].
Преимущества PostgreSQL:
    • Объектно-реляционная модель. Все самые популярные системы реляционные. То есть хранящиеся в них данные представляются в виде записей, связанных друг с другом отношениями (relations). В объектной же модели данные представляются в виде объектов, их атрибутов, методов и классов. PostgreSQL поддерживает оба этих подхода.
    • Поддержка множества типов данных. PostgreSQL поддерживает не только целочисленные значения, числа с плавающей точкой, строки и булевы значения, но так же денежный, бинарный , перечисляемый и другие типы, имеет поддержку XML и JSON.
    • Справляется с большими объемами. В PostgreSQL отсутствуют ограничения по объему базы и количеству записей в ней. Ограничения касаются только того, что одна таблица не может занимать больше 32 Тб, а одна запись — 1,6 Тб. В одном поле может быть не больше 1 Гб данных, а максимальное количество полей зависит от типа и составляет  до 1600 штук. Указанных значений хватает, чтобы хранить в БД любые данные.
    • Поддержка сложных запросов. PostgreSQL поддерживает работу со сложными, составными запросами, что позволяет справляется выполнением трудоемких операций, подразумевающих чтение, запись и валидацию одновременно.
    • Одновременная модификация базы. PostgreSQL допускает возможность одновременного доступа к базе с нескольких устройств. Это достигается за счет клиент-серверной архитектуры (БД хранится на сервере, а доступ к ней осуществляется с клиентских компьютеров). Эта технология называется MVCC (Multiversion Concurrency Control), что в переводе - многоверсионное управление параллельным доступом.
    • Соответствие принципам ACID (атомарность, согласованность, изолированность, прочность). PostgreSQL соответствует этим принципам, что позволяет ей вести себя максимально предсказуемо и надежно, с минимальными рисками возникновения конфликтов или непредвиденного поведения системы.
    • Высокая мощность и широкая функциональность. С одной стороны PostgreSQL очень мощная система с высокой производительностью, позволяющая эффективно обрабатывать большие массивы данных. С другой стороны это пожалуй единственная бесплатная система с открытым исходным кодом.
    • Кроссплатформенность. PostgreSQL поддерживает такие операционные системы как Linux, Windows, macOS и др. PostgreSQL имеет свой автономный веб-сервер с которым можно работать с помощью REST API, так же она доступна для развертывания в облаке.
	У PostgreSQL множество возможностей. Разумно предположить, что мы не будем использовать все её продвинутые функции в нашем проекте, но, поскольку потребности, при дальнейшем развитии проекта, могут возрасти, есть несомненное преимущество в том, чтобы иметь всё это под рукой.', '2022-12-04 03:21:43.151', 'PostgreSQL', 100000011);
INSERT INTO public.report
(id, "content", date_created, title, author_id)
VALUES(10000006, 'DBeaver - универсальный бесплатный менеджер баз данных с открытым исходным кодом. Программа позволяет совершать над базами данных ряд основных действий, таких как создание таблиц, редактирование и экспортирование информации, генерирование скриптов, печать данных, а также создание и запуск различных SQL-запросов [5.].
Среди возможностей программы следует отметить:
- просмотр и редактирование метаданных (таблиц, колонок, ключей, индексов),
- выполнение SQL запросов и скриптов,
- визуальная разметка SQL (отличается для разных движков баз данных),
- автозавершение и гиперссылки в метаданных в редакторе SQL,
- редактирование результирующих таблиц,
- поддержка BLOB/CLOB (режимы просмотра и редактирования),
- скроллинг в наборах ResultSet,
- экспорт данных (таблицы, результаты запросов),
- управление подключениями,
- поиск по объектам баз данных (таблицам, колонкам, процедурам),
- ER-диаграмы,
- закладки в объектах баз данных,
- управление SQL скриптами,
- работа с проектами (соединения, SQL-скрипты и закладки).
Также следует отметить, что DBeaver использует меньше оперативной памяти, чем конкуренты (SQuirreL, DBVisualizer). Метаданные БД загружаются только по мере необходимости, RAM не забивается неиспользуемыми данными. Очень быстро работает просмотрщик ResultSet, также использующий минимум оперативной памяти. Все операции с удаленными БД производятся в «не блокируемом» режиме, DBeaver не зависает при отсутствии ответа от сервера и при выполнении параллельных сетевых задач. Программа является кроссплатформенной.', '2022-12-04 03:22:21.097', 'DBeaver', 100000011);
INSERT INTO public.report
(id, "content", date_created, title, author_id)
VALUES(10000007, '	Ключевым набором решений, описывающих структуру реализуемого программного обеспечения, является его архитектура. Архитектура характеризует набор компонентов, с помощью которых формируется структура приложения. В настоящее время существует два архитектурных стиля, активно используемые разработчиками: REST и GraphQL.
REST — это стиль взаимодействия между компонентами приложения в сети. Преимущества REST-архитектуры:
– Масштабируемость взаимодействия между компонентами приложения.
– Компоненты системы устанавливаются независимо друг от друга.
– Надежность за счет отказоустойчивости.
– Простота и единообразие интерфейса.
	  При использовании архитектурного стиля REST каждый ресурс определяется URL-адресом (унифицированным указателем ресурса), который является указателем на этот информационный блок. Чаще всего данные передаются в формате JSON (JavaScript Object Notation), но возможны и другие форматы, такие как HTML, PNG и PDF.
	 Характерной чертой этого типа архитектуры является то, что он основан на протоколе HTTP. Вот почему ресурсы приложения управляются с помощью таких методов, как GET, POST, PUT и DELETE.
	  GET — это метод, используемый для запроса содержимого ресурса. Параметры запроса передаются после «.». (/api/resource.name=su). Если ресурс не найден, возвращается ответ 404 (не найдено).
	 POST — используется для загрузки новых ресурсов на сервер. Содержимое загружаемых данных помещается в тело запроса. Если загрузка данных прошла успешно, сервер вернет 200 (ОК) или 201 (Создано).
	  PUT — обновить ресурс с указанным идентификатором. Тело запроса должно содержать исходные обновленные данные. Если ресурс не существует, он создается и отправляется ответ 201 (Создано). В противном случае он изменяется с ответом 200 (ОК).
	  DELETE - Удаляет ресурс, указанный его идентификатором. Обычно ничего не возвращается.
	 GraphQL, с другой стороны, представляет собой архитектуру интерфейса приложения с более гибким подходом к программированию. GraphQL не работает с ресурсами выделенными приложениями. Это главное его отличие от REST.
	 GraphQL позволяет разработчикам вносить изменения только во внешнем интерфейсе без подключения к серверу, что ускоряет итерации разработки программного обеспечения во внешнем интерфейсе. Кроме того, разработчики имеют представление о данных запрашиваемых с сервера и как эти данные применяются. Это возможно, потому что с GraphQL клиент сам решает, какая информация ему нужна. Это позволяет разработчикам отказаться от устаревших полей, которые больше не используются клиентом, для повышения производительности API.
	 GraphQL может использовать любой протокол данных. Чтобы манипулировать данными, пользователь обращается к серверу, который является его единственной точкой входа. Изменяя структуру, поля и параметры запроса, клиент обрабатывает разные данные. В отличие от архитектуры REST, которая может возвращать данные в различных форматах, таких как JSON, XML, PDF, GraphQL может отправлять только формат JSON. Стоит добавить, что GraphQL имеет возможность передавать аргументы запроса на произвольные уровни вложенности. Эта архитектура менее строгая, чем REST.
	  После рассмотрения основных характеристик каждой архитектуры, было принято решение использовать REST в проекте.
Основные причины повлиявшие на мой выбор:
- GraphQL использует единую конечную точку входа, без использования кэширования, что влечет увеличение объема трафика и перегрузку сервера.
- Запросы GraphQL могут иметь проблемы с производительностью когда клиент одновременно запрашивает слишком много вложенных полей.
- Разрабатываемое приложение небольшое, ледовательно архитектура REST  будет более рациональным подходом для подключения управляемых компонентов, у которых отсутствует потребность в гибких запросах.
	 Системы, использующие модель клиент-сервер, считаются Restful. Сервер храненит данные, клиент обрабатывает данные обращаясь к серверу, благдаря такому подходу возрастает мобильность клиента. При этом состояние сессии храниться только на стороне клиента. Клиент должен сформулировать запрос таким образом, чтобы он содержал только ту  информацию, которая необходима для его обработки, а в некоторых случаях еще идентификатор пользователя. Кроме того, сервер должен уметь кэшировать данные, т. е. помечать некоторые ответы как кешируемые, чтобы исключить возможность получения клиентом устаревшей или недостоверной информации в ответ на последующие запросы.
	 Restful-система имеет унифицированный интерфейс. Уникальный интерфейс позволяет самостоятельно развиваться отдельным сервисам приложения. У данного подхода есть четыре принципа: – наличие идентификатора ресурса (URI); – манипулирование ресурсами путем представления; – самодокументирующиеся сообщения; – гипермедиа как механизм состояния приложения. Использование промежуточных серверов улучшает масштабируемость вашей REST системы, т.к. промежуточные серверы позволяют сбалансировать нагрузку и распределить кэширование между ними. На рис. 2.1 представлена схема разработанного приложения. Это соответствует архитектуре REST.
Рисунок 3.1 —  REST архитектура
	 Архитектура REST не привязана к какой-либо конкретной технологии или протоколу, однако для создания Restful API необходимо обязательно использовать HTTP и формат обмена данными. При разработке приложения Менеджер собраний используются методы передачи данных по протоколу HTTP, к примеру  GET и POST.', '2022-12-04 03:23:20.369', 'Архитектура приложения', 10000009);
INSERT INTO public.report
(id, "content", date_created, title, author_id)
VALUES(10000008, '	Ключевым набором решений, описывающих структуру реализуемого программного обеспечения, является его архитектура. Архитектура характеризует набор компонентов, с помощью которых формируется структура приложения. В настоящее время существует два архитектурных стиля, активно используемые разработчиками: REST и GraphQL.
REST — это стиль взаимодействия между компонентами приложения в сети. Преимущества REST-архитектуры:
– Масштабируемость взаимодействия между компонентами приложения.
– Компоненты системы устанавливаются независимо друг от друга.
– Надежность за счет отказоустойчивости.
– Простота и единообразие интерфейса.
	  При использовании архитектурного стиля REST каждый ресурс определяется URL-адресом (унифицированным указателем ресурса), который является указателем на этот информационный блок. Чаще всего данные передаются в формате JSON (JavaScript Object Notation), но возможны и другие форматы, такие как HTML, PNG и PDF.
	 Характерной чертой этого типа архитектуры является то, что он основан на протоколе HTTP. Вот почему ресурсы приложения управляются с помощью таких методов, как GET, POST, PUT и DELETE.
	  GET — это метод, используемый для запроса содержимого ресурса. Параметры запроса передаются после «.». (/api/resource.name=su). Если ресурс не найден, возвращается ответ 404 (не найдено).
	 POST — используется для загрузки новых ресурсов на сервер. Содержимое загружаемых данных помещается в тело запроса. Если загрузка данных прошла успешно, сервер вернет 200 (ОК) или 201 (Создано).
	  PUT — обновить ресурс с указанным идентификатором. Тело запроса должно содержать исходные обновленные данные. Если ресурс не существует, он создается и отправляется ответ 201 (Создано). В противном случае он изменяется с ответом 200 (ОК).
	  DELETE - Удаляет ресурс, указанный его идентификатором. Обычно ничего не возвращается.
	 GraphQL, с другой стороны, представляет собой архитектуру интерфейса приложения с более гибким подходом к программированию. GraphQL не работает с ресурсами выделенными приложениями. Это главное его отличие от REST.
	 GraphQL позволяет разработчикам вносить изменения только во внешнем интерфейсе без подключения к серверу, что ускоряет итерации разработки программного обеспечения во внешнем интерфейсе. Кроме того, разработчики имеют представление о данных запрашиваемых с сервера и как эти данные применяются. Это возможно, потому что с GraphQL клиент сам решает, какая информация ему нужна. Это позволяет разработчикам отказаться от устаревших полей, которые больше не используются клиентом, для повышения производительности API.
	 GraphQL может использовать любой протокол данных. Чтобы манипулировать данными, пользователь обращается к серверу, который является его единственной точкой входа. Изменяя структуру, поля и параметры запроса, клиент обрабатывает разные данные. В отличие от архитектуры REST, которая может возвращать данные в различных форматах, таких как JSON, XML, PDF, GraphQL может отправлять только формат JSON. Стоит добавить, что GraphQL имеет возможность передавать аргументы запроса на произвольные уровни вложенности. Эта архитектура менее строгая, чем REST.
	  После рассмотрения основных характеристик каждой архитектуры, было принято решение использовать REST в проекте.
Основные причины повлиявшие на мой выбор:
- GraphQL использует единую конечную точку входа, без использования кэширования, что влечет увеличение объема трафика и перегрузку сервера.
- Запросы GraphQL могут иметь проблемы с производительностью когда клиент одновременно запрашивает слишком много вложенных полей.
- Разрабатываемое приложение небольшое, ледовательно архитектура REST  будет более рациональным подходом для подключения управляемых компонентов, у которых отсутствует потребность в гибких запросах.
	 Системы, использующие модель клиент-сервер, считаются Restful. Сервер храненит данные, клиент обрабатывает данные обращаясь к серверу, благдаря такому подходу возрастает мобильность клиента. При этом состояние сессии храниться только на стороне клиента. Клиент должен сформулировать запрос таким образом, чтобы он содержал только ту  информацию, которая необходима для его обработки, а в некоторых случаях еще идентификатор пользователя. Кроме того, сервер должен уметь кэшировать данные, т. е. помечать некоторые ответы как кешируемые, чтобы исключить возможность получения клиентом устаревшей или недостоверной информации в ответ на последующие запросы.
	 Restful-система имеет унифицированный интерфейс. Уникальный интерфейс позволяет самостоятельно развиваться отдельным сервисам приложения. У данного подхода есть четыре принципа: – наличие идентификатора ресурса (URI); – манипулирование ресурсами путем представления; – самодокументирующиеся сообщения; – гипермедиа как механизм состояния приложения. Использование промежуточных серверов улучшает масштабируемость вашей REST системы, т.к. промежуточные серверы позволяют сбалансировать нагрузку и распределить кэширование между ними. На рис. 2.1 представлена схема разработанного приложения. Это соответствует архитектуре REST.
Рисунок 3.1 —  REST архитектура
	 Архитектура REST не привязана к какой-либо конкретной технологии или протоколу, однако для создания Restful API необходимо обязательно использовать HTTP и формат обмена данными. При разработке приложения Менеджер собраний используются методы передачи данных по протоколу HTTP, к примеру  GET и POST.', '2022-12-04 03:23:39.101', 'Архитектура приложения', 10000009);
INSERT INTO public.report
(id, "content", date_created, title, author_id)
VALUES(10000009, 'Разработка базы данных
	 Опираясь на функции, которые должен обеспечивать проект, база данных требует наличия сущностей и их связей, которые мы определим в данной главе.
	Прежде чем браться за моделирование базы данных, необходимо определить какие виды данных будут в ней храниться и на какие категории мы можем их разделить.
	Сотрудник – работник предприятия, он же пользователь приложения, который может участвовать в собраниях, быть докладчиком на них.
	Роль – описание совокупности возможностей, которые может выполнять пользователь.
	Отдел – структурное подразделение предприятия, которому принадлежат сотрудники.
	Доклад – подготовленное изложение какой-либо темы, запланированной для представления на собрании.
	Собрание – встреча определенного круга сотрудников.
	Исходя из правил объектно-реляционной модели, все объекты должны быть представлены в отдельных таблицах. Благодаря технологии ORM, нет необходимости описывать таблицы вручную. ORM это технология программирования, позволяющая преобразовывать части кода объектно-ориентированных языков программирования в SQL запросы, что позволяет получить виртуальную объектную базу данных. В нашем проекте, для этих целей, определен для использования Hibernate [4.].
	В разрабатываемом приложении объекты имеют внешние связи друг с другом, которые можно описать как отношения. В структуре БД построим эти связи используя внешние ключи, которые помогут установить соответствие между записями нужных таблиц.
	Существует несколько видов отношений.
	Многие ко многим – вид связи, при котором каждой записи из таблицы
соответствует одна и более записей другой таблицы. Для реализации такого вида связи применяется дополнительная таблица, которая содержит внешние ключи связываемых таблиц.
	Один ко многим – вид связи, при котором одна запись из таблицы А может быть связана с многими записями таблицы Б, но запись в таблице Б, может быть связана только с одной записью таблицы А.
	Один к одному – вид связи, при котором одна запись из родительской таблицы может быть связана только с одной записью дочерней таблицы. Чтобы избежать здесь связи один ко многим, необходимо сделать внешний ключ одной из таблиц уникальным.
	  Рассмотрим основные таблицы приложения Менеджер собраний.
	 Таблица Employee представляет сотрудника предприятия в системе. Объект состоит из идентификатора, имени, даты рождения, электронной почты, логина, пароля, идентификатора принадлежности к определенному Отделу, а также роли и статуса для определения  разрешений сотрудника. Сотрудник может быть зарегистрирован как пользователь или администратор.
	 Собрание (Meeting) представляет собой набор сотрудников, которых планируется пригласить  в конкретный день. Собрание содержит идентификатор, дату проведения, тему, организатора, информацию о докладе, а также состояние (ожидает проведения, в процессе или окончено).
	  В таблице Report представлены тексты и названия докладов, сохраненных для рассмотрения на собраниях. В данном объекте, помимо наименования и текста, содержится дата создания этого доклада и имя автора.
	  Также мы имеем таблицу Department (Отдел) хранящую информацию о структурных подразделениях предприятия, и таблицу Participants, в которой хранятся отношения сотрудников и собраний, для определения участников собраний. В последней таблице хранятся данные с отношением многие ко многим.
	  Еще в структуре БД мы имеем таблицы ролей и статусов (role, status), которые позволяют нам осуществлять контроль доступа сотрудников к определенным функциям приложения, в зависимости от утвержденной ролевой модели.
	 Отношения между таблицами будут обсуждаться в Реализации. Свойства таблиц и их связи изображены на рисунке 3.2. ', '2022-12-04 03:24:29.444', 'Разработка базы данных', 10000005);
INSERT INTO public.report
(id, "content", date_created, title, author_id)
VALUES(100000010, 'Разработка серверной части приложения
	 Запросы к аппаратной и программной части веб-приложения осуществляются по адресу «http://localhost:8080». Например, чтобы отправить клиенту список собраний по запросу, используется запрос POST. Для этого необходимо добавить выражение «/search_meeting/submit» к основному пути. Запросы создаются на этапе реализации контроллера, который является центральным компонентом, обрабатывающим запросы пользователей. Однако есть ряд элементов системы, которые должны присутствовать до того, как мы приступим к созданию контроллера. Детальное описание представлено в Приложении В.
	  В первую очередь при разработке приложения создается модель. Это компонент, который предоставляет данные и меняет свое состояние по командам поступающим от контроллера. Модель — это обычный класс, описывающий свойства столбцов таблицы, с которой он сопоставляется.
Давайте взглянем на модель Meeting, показанную в листинге программы (Приложение В). Аннотация @Entity обозначает то, что класс должен представлять таблицу в базе данных. Тело класса описывает характеристики объекта (идентификатор, дата проведения, название, отдел, организатор и т. д.). Далее следует обязательный пустой конструктор и конструктор, описывающий создание нового объекта для этой модели. Наконец, нам нужно добавить геттеры и сеттеры, методы чтения и записи свойств объекта.
	 После модели необходимо создать репозиторий, являющийся механизмом доступа к базе данных, а также отвечающий за извлечение и хранение объектов той или иной модели. В листинге программы (Приложение В) показан пример создания репозитория на основе класса Meeting. Аннотация @Repository означает, что описываемый интерфейс является репозиторием. Репозиторий должен наследоваться от интерфейса JpaRepository с установленными параметрами, позволяющими идентифицировать модель (название и идентификатор модели).
	  Последним шагом является создание контроллера. Как отмечалось выше, он несет в себе описание запросов пользователя. Контроллер управляет данными и направляет их от пользователя к системе и наоборот. Обратите внимание, что у каждого контроллера обязательно имеется свой уникальный адрес доступа. Рассмотрим запрос POST, показанный в листинге программы (Приложение В). Этот метод получает все объекты из таблицы собраний  соответствующие переданным параметрам и возвращает код 200 (ОК). Схема взаимодействия компонентов системы представлена на рисунке 3.5.
Рисунок 3.5 – Диаграмма последовательности
	  Все остальные методы этого контроллера работают аналогично (Приложение В). Доступ к разным методам имеют разные группы пользователей, в зависимости от имеющихся пермитов, о чем свидетельствует аннотация @PreAuthorize. Метод createMeeting() создает новый объект класса Meeting, после чего он сохраняется в базе данных на сервере. Метод deleteMeeting (), напротив, удаляет объект из таблицы по его идентификатору.
 	 Остальные компоненты приложения реализованы основываясь на принципах, описанных в этой главе.', '2022-12-04 03:25:30.640', 'Разработка серверной части приложения', 100000010);

-- Собрания
INSERT INTO public.meeting
(id, date_spending, topic, organized_department_id, organized_employee_id, report_id)
VALUES(10000001, '2022-10-10 00:00:00.000', 'Начало', 0, 10000005, 10000001);
INSERT INTO public.meeting
(id, date_spending, topic, organized_department_id, organized_employee_id, report_id)
VALUES(10000002, '2022-10-15 00:00:00.000', 'Анализ рынка', 10000001, 10000002, 10000007);
INSERT INTO public.meeting
(id, date_spending, topic, organized_department_id, organized_employee_id, report_id)
VALUES(10000003, '2022-10-24 00:00:00.000', 'Выбор инструментов', 10000002, 10000009, 10000003);
INSERT INTO public.meeting
(id, date_spending, topic, organized_department_id, organized_employee_id, report_id)
VALUES(10000004, '2022-10-24 00:00:00.000', 'Выбор языка программирования', 10000002, 10000009, 10000002);
INSERT INTO public.meeting
(id, date_spending, topic, organized_department_id, organized_employee_id, report_id)
VALUES(10000005, '2022-11-01 00:00:00.000', 'Выбор СУБД', 10000004, 10000007, 10000005);

-- Участники
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000001, 10000002);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000001, 10000003);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000001, 10000001);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000001, 10000005);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000001, 10000006);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000001, 10000007);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000001, 10000008);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000001, 10000009);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000001, 100000010);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000001, 100000011);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000002, 10000002);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000002, 10000003);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000002, 10000006);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000002, 10000009);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000003, 10000003);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000003, 10000001);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000003, 10000005);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000003, 10000009);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000003, 100000010);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000004, 10000003);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000004, 10000001);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000004, 10000005);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000004, 10000007);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000004, 10000009);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000004, 100000010);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000005, 10000002);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000005, 10000005);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000005, 10000007);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000005, 10000008);
INSERT INTO public.participants
(meeting_id, employee_id)
VALUES(10000005, 100000010);
